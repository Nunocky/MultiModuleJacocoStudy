// Merge of
// https://gist.github.com/danielgomezrico/55cb6175267dee6a72737e4ff0921469
// https://qiita.com/keidroid/items/adc4f065b84d8a2cd17a

// Requires Jacoco plugin in build classpath.
apply plugin: 'jacoco'

jacoco {
    toolVersion = rootProject.ext.jacoco_version
}

// Enable test result in terminal
tasks.withType(Test) {
    testLogging {
        exceptionFormat "full"
        events "skipped", "passed", "failed"
        showStandardStreams true
    }

    jacoco.includeNoLocationClasses = true
}

variants().all { variant ->
    def tag = "[jacoco-module.gradle]"
    def variantName = variant.name
    def variantCapName = variant.name.capitalize()
    def fullTestTask = "testSuite${variantCapName}JacocoReport"
    def unitTestTask = "test${variantCapName}UnitTest"

    //
    // use create<>CoverateReport since connectedCheck task does not generate jacoco reports so we
    // need to depend on tasks that run tests + coverage
    //
    def instrumentedTestTask = "create${variantCapName}CoverageReport"

    if (variantCapName == "Release") {
        logger.info "$tag ${project.name} Task '$fullTestTask' is not enabled for Release builds."
        return
    }

    if (project.tasks.findByName(unitTestTask) == null ||
            project.tasks.findByName(instrumentedTestTask) ==
            null) {
        logger.warn "$tag ${project.name} Task '$fullTestTask' was not created, you can enable it by passing -PcoverageEnabled or by setting testCoverageEnabled=true in gradle.android setup."

        return
    }

    task(fullTestTask, type: JacocoReport, dependsOn: [instrumentedTestTask, unitTestTask]) {

        group = "Reporting"
        description =
                "Generate Jacoco coverage reports for $variantCapName Instrumented and UnitTest Tests"
        onlyIf = { return true }

        reports {
            xml.enabled = true
            html.enabled = true
            csv.enabled = false
        }

        def androidFilter = ['**/R.class',
                             '**/R$*.class',
                             '**/BuildConfig.*',
                             '**/Manifest*.*',
                             '**/*$ViewInjector*.*',
                             '**/*$ViewBinder*.*',
                             '**/*$Lambda$*.*', // Jacoco can not handle several "$" in class name.
                             '**/*Module.*', // Modules for Dagger.
                             '**/*Dagger*.*', // Dagger auto-generated code.
                             '**/*MembersInjector*.*', // Dagger auto-generated code.
                             '**/*_Provide*Factory*.*',
                             '**/*_Factory.*', //Dagger auto-generated code
                             '**/*$*$*.*', // Anonymous classes generated by kotlin
                             //add libraries
                             'androidx/**/*.*',
                             'android/**/*.*',
                             //remove what we don't test
                             'androidTest/**/*.*',
                             'test/**/*.*',
                             '**/injector/**/*.*',
                             '**/model/**/*.*',
                             '**/mock/**/*.*',
                             '**/event/**/*.*',
                             '**/**_ViewBinding**',
                             '**/*EventType.*',
                             '**/**Mocked']

        def librariesFilter = ['**/com/barista_v/**/*.*',
                               '**/com/baristav/**/*.*',
                               '**/com/esotericsoftware/**/*.*',
                               '**/com/crashlytics/**/*.*',
                               '**/com/facebook/**/*.*',
                               '**/com/jakewharton/**/*.*',
                               '**/com/onesignal/**/*.*',
                               '**/com/viewpagerindicator/**/*.*',
                               '**/io/fabric/**/*.*',
                               '**/io/reactivex/**/*.*',
                               '**/net/danlew/**/*.*',
                               '**/timber/**/*.*',
                               '**/removeme/**/*.*',
                               '**/squareup/**/*.*',]

        def fileFilter = androidFilter + librariesFilter

//        def classTree = fileTree(dir: variant.javaCompiler.destinationDir, excludes: fileFilter) +
//                fileTree(dir: "$buildDir/tmp/kotlin-classes/$variantName", excludes: fileFilter)

        def javaDebugTree = fileTree(dir: "${buildDir}/intermediates/javac/${variantName}/compile${variantName}JavaWithJavac/classes", excludes: fileFilter)
        def kotlinDebugTree = fileTree(dir: "${buildDir}/tmp/kotlin-classes/${variantName}", excludes: fileFilter)

        def mainSrc = "${project.projectDir}/src/main/java"

        getSourceDirectories().setFrom(files([mainSrc]))

        getClassDirectories().setFrom(files([javaDebugTree, kotlinDebugTree]))
        getExecutionData().setFrom(fileTree(dir: project.projectDir, includes: [
                '**/*.exec',    //JUnit Test Result
                '**/*.ec'])     //Espresso Test Result
        )

        doLast {
            println "Custom $fullTestTask Jacoco task run for instrumented and unit-tests."
        }
    }
}

def variants() {
    if (project.android.hasProperty('libraryVariants')) {
        return project.android.libraryVariants
    } else {
        return project.android.applicationVariants
    }
}